<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BlockBlast — Pro Edition</title>

<!-- Font -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;800&display=swap" rel="stylesheet">

<style>
/* ===========================================================
   THEME + BASE
   ===========================================================
*/
:root{
  --bg-a: #071026;
  --bg-b: #0b2a45;
  --panel: rgba(255,255,255,0.03);
  --accent: #4fd1ff;
  --accent-2: #2b9fe6;
  --muted: rgba(255,255,255,0.7);
  --cell-size: 50px; /* main cell size */
  --gap: 14px;
  --card-radius: 14px;
  --shadow-strong: 0 18px 50px rgba(2,6,23,0.6);
  --glass: rgba(255,255,255,0.03);
  --text: #e9f9ff;
  --ui-0: rgba(255,255,255,0.04);
  --ui-1: rgba(255,255,255,0.02);
}

*{box-sizing:border-box}
html,body{height:100%;margin:0;background: radial-gradient(900px 400px at 10% 8%, rgba(79,209,255,0.04), transparent 6%), linear-gradient(180deg,var(--bg-a),var(--bg-b)); color:var(--text); font-family:'Poppins',system-ui,Segoe UI,Roboto,Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}

/* Container */
.container{max-width:1180px;margin:28px auto;padding:18px;display:flex;gap:20px;align-items:flex-start;justify-content:center}
.left{flex:1;min-width:560px}
.right{width:360px}

/* Card */
.card{background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:var(--card-radius); padding:14px; box-shadow: var(--shadow-strong);}

/* Header */
.header-row{display:flex;justify-content:space-between;align-items:center;gap:12px}
.brand{display:flex;flex-direction:column}
.brand h1{margin:0;font-size:20px;color:var(--accent)}
.brand p{margin:2px 0 0;font-size:12px;color:var(--muted)}

/* board panel */
.boardWrap{margin-top:12px; padding:14px;border-radius:12px;background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.04));}

/* board grid: responsive cell size using CSS var */
#board{
  display:grid;
  grid-template-columns: repeat(9, var(--cell-size));
  grid-auto-rows: var(--cell-size);
  gap: var(--gap);
  padding:12px;
  border-radius:12px;
  width: calc(9 * var(--cell-size) + 8 * var(--gap) + 24px); /* padding compensation */
  margin: 0 auto;
  background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03));
  position:relative;
  transition: filter 220ms ease, transform 220ms ease;
}

/* Cells: grid lines, glow, filled */
.cell{
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
  border-radius:10px;
  border: 1px solid rgba(255,255,255,0.04);
  position:relative;
  overflow:hidden;
  transition: transform 160ms cubic-bezier(.2,.9,.2,1), box-shadow 160ms, background 160ms;
}
.cell::after{ content:''; position:absolute; inset:0; border-radius:10px; pointer-events:none; }

/* gridline stronger */
.cell.gridline{ border: 1px solid rgba(255,255,255,0.08); }

/* highlight preview */
.cell.preview{
  box-shadow: 0 18px 50px rgba(79,209,255,0.08), inset 0 6px 18px rgba(79,209,255,0.04);
  transform: translateY(-6px);
}

/* filled cell style: gradient and soft shadow */
.cell.filled{
  background: linear-gradient(180deg,var(--accent),var(--accent-2));
  box-shadow: 0 12px 38px rgba(43,159,230,0.20), inset 0 6px 12px rgba(255,255,255,0.06);
  transform: translateY(0);
}

/* pop animation on place */
@keyframes pop { 0%{ transform: scale(.6); } 70%{ transform: scale(1.08); } 100%{ transform: scale(1); } }
.cell.pop{
  animation: pop 260ms cubic-bezier(.2,.9,.2,1);
}

/* explode animation when clearing */
@keyframes explode { to{ transform: scale(1.8); opacity:0; } }
.cell.explode{
  animation: explode 360ms ease-out forwards;
}

/* flash entire board */
.flash { animation: flashBoard 360ms ease; }
@keyframes flashBoard { 0%{ filter:brightness(2) } 100%{ filter:brightness(1) } }

/* particle container */
#particleLayer {
  position: absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; overflow:visible; z-index:60;
}

/* slot area (right pane) */
.slots{display:flex;gap:12px;justify-content:center;padding:10px}
.slot{min-width:110px;padding:12px;border-radius:12px;background:var(--ui-0);display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;transition:transform 120ms, opacity 140ms}
.slot.empty{opacity:0.2; pointer-events:none; transform:scale(.98)}
.previewGrid{display:inline-grid;gap:6px}
.previewRow{display:flex;gap:6px;justify-content:center}
.previewCell{width:28px;height:28px;border-radius:8px;background:rgba(255,255,255,0.04)}

/* ghost */
.ghost{
  position:fixed; z-index:80; pointer-events:none; transform:translate(-50%,-50%) scale(1.04); filter:drop-shadow(0 18px 40px rgba(0,0,0,0.45));
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:8px; border-radius:10px; will-change: transform;
}

/* UI controls */
.statRow{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.statLabel{font-size:13px;color:var(--muted)}
.statValue{font-weight:800;color:var(--accent);font-size:20px}

/* buttons */
.btn{background:var(--accent);border:none;padding:8px 12px;border-radius:10px;color:#031018;font-weight:700;cursor:pointer}
.btnGhost{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--text);cursor:pointer}

/* Overlay gameover */
.overlay{position:fixed;inset:0;background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.6));display:flex;align-items:center;justify-content:center;z-index:120;backdrop-filter: blur(4px);opacity:0;pointer-events:none;transition:opacity 180ms ease}
.overlay.show{opacity:1;pointer-events:auto}
.overlayPanel{background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.06)); padding:20px;border-radius:12px;text-align:center;min-width:320px}

:root{
  --gap: 14px;
}

.previewGrid{ gap:10px; }
.previewCell{ width:32px; height:32px; }

.slots{ gap:20px; }

.ghost{ will-change: transform; }

/* small responsive */
@media (max-width:980px){
  .container{flex-direction:column;padding:12px}
  .right{width:100%}
  #board{transform:scale(.82);transform-origin:top center}
}
</style>
</head>
<body>

<!-- ========= MAIN LAYOUT ========= -->
<div class="container">
  <!-- LEFT: Board -->
  <div class="left card">
    <div class="header-row">
      <div class="brand">
        <h1>BlockBlast — Pro Edition</h1>
        <p class="meta">Kéo thả mảnh — block rơi đẹp — particles & combo</p>
      </div>
      <div style="text-align:right">
        <div class="statLabel">BEST</div>
        <div id="bestVal" class="statValue">0</div>
      </div>
    </div>

    <div class="boardWrap" style="margin-top:12px">
      <div id="board" aria-label="Game board">
        <!-- cells inserted by JS -->
        <div id="particleLayer"></div>
      </div>
    </div>
  </div>

  <!-- RIGHT: UI -->
  <div class="right">
    <div class="card">
      <div class="statRow">
        <div>
          <div class="statLabel">SCORE</div>
          <div id="scoreVal" class="statValue">0</div>
        </div>
        <div>
          <div class="statLabel">COMBO</div>
          <div id="comboVal" class="statValue" style="color:var(--muted);font-size:16px">x1</div>
        </div>
      </div>

      <div style="margin-top:6px" class="statRow">
        <div class="statLabel">Palette</div>
        <div style="display:flex;gap:8px">
          <button id="btnPalette" class="btnGhost">Random</button>
          <button id="btnTheme" class="btnGhost">Dark/Light</button>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="statLabel" style="margin-bottom:8px">Pieces (Kéo để đặt)</div>
      <div id="slots" class="slots"></div>
      <div style="display:flex;gap:10px;justify-content:center;margin-top:10px">
        <button id="btnNew" class="btn">New Pieces</button>
        <button id="btnReset" class="btnGhost">Reset</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="statLabel">Tips</div>
      <div class="meta" style="margin-top:8px; font-size:13px; color:var(--muted)">
        Nếu cả 3 mảnh không thể đặt ở đâu → <b>Game Over</b>. Khi clear hàng/cột → đổi palette & có particle.
      </div>
    </div>
  </div>
</div>

<!-- GAME OVER OVERLAY -->
<div id="overlay" class="overlay" role="dialog" aria-hidden="true">
  <div class="overlayPanel">
    <h2 id="goTitle" style="margin:0 0 8px 0">Game Over</h2>
    <div id="goMsg" class="meta" style="margin-bottom:12px">Bạn không thể đặt bất kỳ mảnh nào. Chơi lại?</div>
    <div style="display:flex;gap:10px;justify-content:center">
      <button id="btnRestart" class="btn">Restart</button>
      <button id="btnClose" class="btnGhost">Close</button>
    </div>
    <div style="height:8px"></div>
    <div class="meta" style="font-size:12px">Best score được lưu ở localStorage.</div>
  </div>
</div>

<!-- SOUND (optional, browser may block auto-play) -->
<audio id="sPlace" src="" preload="auto"></audio>
<audio id="sClear" src="" preload="auto"></audio>
<audio id="sCombo" src="" preload="auto"></audio>

<script>
/* ===========================================================
   GAME ENGINE (single-file)
   - Based on your last code, upgraded with:
     • Block falling animation
     • Flash + particles on clear
     • Game Over + restart overlay
     • Scoring per spec (7 per cell, 100 per line, combos, perfect, full)
     • Visual polish & theme palette swap
   ===========================================================
*/

/* -------------------- CONFIG -------------------- */
const ROWS = 9, COLS = 9;
const POINT_CELL = 7;
const POINT_LINE = 100;
const PERFECT_BONUS = 150;
const FULL_CLEAR_BONUS = 500;

/* palettes (board bg + block color) */
const PALETTES = [
  {bg0:'#071026', bg1:'#0b2a45', block:'#4D96FF'},
  {bg0:'#061e13', bg1:'#133a24', block:'#6BCB77'},
  {bg0:'#2a0812', bg1:'#3b0f1c', block:'#FF6B6B'},
  {bg0:'#2b1808', bg1:'#403012', block:'#FFD93D'},
  {bg0:'#10021b', bg1:'#2b1240', block:'#9D4EDD'},
  {bg0:'#02131a', bg1:'#072836', block:'#32c5ff'}
];

/* shapes list (a superset for variety) */
const SHAPES = [
  [[1]],
  [[1,1]],
  [[1,1,1]],
  [[1],[1]],
  [[1],[1],[1]],
  [[1,1],[1,1]],
  [[1,0],[1,1]],
  [[0,1],[1,1]],
  [[1,1,1],[0,1,0]],
  [[1,1,0],[0,1,1]],
  [[1,1,1,1]],
  [[1],[1],[1],[1]],
  [[1,0,0],[1,1,1]], // L long
  [[0,1,0],[1,1,1]], // T already
  [[1,0],[1,0],[1,1]] // L vertical
];

/* -------------------- STATE -------------------- */
let grid = []; // 2D grid 0/1
let pieces = []; // [{shape:[], used:false}, ...] length 3
let score = 0, combo = 1;
let best = Number(localStorage.getItem('bb_best_pro_v2') || 0);
let currentPalette = PALETTES[0];

/* UI elements */
const BOARD = document.getElementById('board');
const SLOTS = document.getElementById('slots');
const SCORE_EL = document.getElementById('scoreVal');
const BEST_EL = document.getElementById('bestVal');
const COMBO_EL = document.getElementById('comboVal');
const OVERLAY = document.getElementById('overlay');
const PARTICLE_LAYER = document.getElementById('particleLayer');

/* audio placeholders (empty by default) */
const S_PLACE = document.getElementById('sPlace');
const S_CLEAR = document.getElementById('sClear');
const S_COMBO = document.getElementById('sCombo');

/* drag state */
let ghost = null;
let dragInfo = null; // {idx, shape}
let pointerMoveHandler = null, pointerUpHandler = null;

/* -------------------- UTIL -------------------- */
function rand(n){ return Math.floor(Math.random()*n); }
function pick(a){ return a[rand(a.length)]; }
function clone(x){ return JSON.parse(JSON.stringify(x)); }

/* -------------------- INITIALIZE -------------------- */
function initGrid(){
  grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
}
function buildBoardDOM(){
  BOARD.innerHTML = '';
  // create cells
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell gridline';
      cell.dataset.r = r; cell.dataset.c = c;
      BOARD.appendChild(cell);
    }
  }
  // particle layer sits on top
  const pLayer = document.createElement('div');
  pLayer.id = 'particleLayer';
  BOARD.appendChild(pLayer);
}
function renderGrid(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      const el = BOARD.children[idx];
      if (!el) continue;
      if (grid[r][c] === 1){
        el.classList.add('filled');
      } else {
        el.classList.remove('filled','explode','preview','pop','glow');
      }
    }
  }
}

/* -------------------- Palette -------------------- */
function applyPalette(p){
  currentPalette = p;
  // set CSS variables for gradients and block look
  document.documentElement.style.setProperty('--bg-a', p.bg0);
  document.documentElement.style.setProperty('--bg-b', p.bg1);
  // set accent to block color for UI
  document.documentElement.style.setProperty('--accent', p.block);
  // create a darker stop for gradient
  function shade(hex, pct){
    const f = hex.slice(1);
    const R = parseInt(f.substring(0,2),16), G = parseInt(f.substring(2,4),16), B = parseInt(f.substring(4,6),16);
    const t = pct<0?0:255; const p2=Math.abs(pct)/100;
    const newR = Math.round((t - R)*p2) + R;
    const newG = Math.round((t - G)*p2) + G;
    const newB = Math.round((t - B)*p2) + B;
    return `rgb(${newR},${newG},${newB})`;
  }
  const darker = shade(p.block, -22);
  document.documentElement.style.setProperty('--accent-2', darker);
  // update existing mini previews
  document.querySelectorAll('.previewCell').forEach(el=>{
    if (el.dataset.filled === '1') el.style.background = p.block;
  });
}

/* -------------------- PIECES: generate + render -------------------- */
function genPiece(){ return clone(pick(SHAPES)); }

function generatePieces(){
  pieces = [
    {shape: genPiece(), used:false},
    {shape: genPiece(), used:false},
    {shape: genPiece(), used:false}
  ];
  renderPieces();
}

/* render three slots */
function renderPieces(){
  SLOTS.innerHTML = '';
  pieces.forEach((p, idx)=>{
    const slot = document.createElement('div');
    slot.className = 'slot';
    slot.dataset.idx = idx;

    if (p.used || !p.shape || p.shape.length===0){
      slot.classList.add('empty');
      slot.innerHTML = '<div style="color:var(--muted)">Used</div>';
      SLOTS.appendChild(slot);
      return;
    }

    const preview = document.createElement('div');
    preview.className = 'previewGrid';
    // grid columns = columns in shape
    const cols = Math.max(...p.shape.map(r => r.length));
    preview.style.gridTemplateColumns = `repeat(${cols}, auto)`;

    p.shape.forEach(row=>{
      const rowEl = document.createElement('div');
      rowEl.className = 'previewRow';
      row.forEach(cell=>{
        const mini = document.createElement('div');
        mini.className = 'previewCell';
        if (cell===1){
          mini.dataset.filled = '1';
          mini.style.background = currentPalette.block;
        } else {
          mini.dataset.filled = '0';
          mini.style.background = 'rgba(255,255,255,0.03)';
        }
        rowEl.appendChild(mini);
      });
      preview.appendChild(rowEl);
    });

    slot.appendChild(preview);

    // pointerdown starts drag
    slot.addEventListener('pointerdown', (ev)=>{
      ev.preventDefault();
      if (p.used) return;
      startDrag(ev, idx);
    });

    SLOTS.appendChild(slot);
  });
}

/* -------------------- DRAG / GHOST -------------------- */
function startDrag(ev, idx){
  dragInfo = { idx, shape: clone(pieces[idx].shape) };
  // build ghost
  ghost = document.createElement('div');
  ghost.className = 'ghost';
  ghost.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))';
  ghost.style.padding = '8px';
  ghost.style.borderRadius = '10px';
  // draw shape inside ghost
  dragInfo.shape.forEach(row=>{
    const rEl = document.createElement('div');
    rEl.style.display='flex'; rEl.style.gap='6px'; rEl.style.justifyContent='center';
    row.forEach(cell=>{
      const b = document.createElement('div');
      b.style.width='36px'; b.style.height='36px'; b.style.borderRadius='8px';
      if (cell===1){ b.style.background = currentPalette.block; b.style.boxShadow = 'inset 0 6px 12px rgba(255,255,255,0.06)'; }
      else b.style.background = 'rgba(255,255,255,0.03)';
      rEl.appendChild(b);
    });
    ghost.appendChild(rEl);
  });

  document.body.appendChild(ghost);
  moveGhost(ev);

  // attach pointer move/up
  pointerMoveHandler = (e)=>{ moveGhost(e); updatePreviewGlow(e); };
  pointerUpHandler = (e)=>{ finishDrag(e); document.removeEventListener('pointermove', pointerMoveHandler); document.removeEventListener('pointerup', pointerUpHandler); };
  document.addEventListener('pointermove', pointerMoveHandler);
  document.addEventListener('pointerup', pointerUpHandler);
}

function moveGhost(e){
  if (!ghost) return;
  ghost.style.left = (e.pageX) + 'px';
  ghost.style.top = (e.pageY) + 'px';
}

function finishDrag(e){
  if (!dragInfo) return;
  const rect = BOARD.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const cellW = rect.width / COLS;
  const cellH = rect.height / ROWS;
  const c = Math.floor(x / cellW);
  const r = Math.floor(y / cellH);

  const idx = dragInfo.idx;
  const placed = tryPlaceAt(dragInfo.shape, r, c, idx);

  // remove ghost
  if (ghost){ ghost.remove(); ghost = null; }
  dragInfo = null;
  clearAllPreview();
  // after placement actions
  if (placed){
    // if all used, generate new after short delay
    if (pieces.every(p=>p.used || !p.shape || p.shape.length ===0)){
      setTimeout(()=>{ generatePieces(); checkGameOver(); }, 300);
    } else {
      setTimeout(()=> checkGameOver(), 120);
    }
  } else {
    // nothing placed, still check nothing
    setTimeout(()=> checkGameOver(), 120);
  }
}

/* allow click-to-place too: click slot then click board */
let selectedSlot = null;
SLOTS.addEventListener('click', (ev)=>{
  const slot = ev.target.closest('.slot');
  if (!slot) return;
  const idx = Number(slot.dataset.idx);
  if (pieces[idx] && !pieces[idx].used && pieces[idx].shape.length) {
    // toggle selection
    if (selectedSlot === idx){
      selectedSlot = null;
      clearAllPreview();
    } else {
      selectedSlot = idx;
      // attach click handler to board overlay
    }
  }
});
BOARD.addEventListener('click', (ev)=>{
  if (selectedSlot === null) return;
  const rect = BOARD.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  const cellW = rect.width / COLS;
  const cellH = rect.height / ROWS;
  const c = Math.floor(x / cellW);
  const r = Math.floor(y / cellH);
  const idx = selectedSlot;
  const placed = tryPlaceAt(pieces[idx].shape, r, c, idx);
  selectedSlot = null;
  clearAllPreview();
  if (placed){
    if (pieces.every(p=>p.used || !p.shape || p.shape.length===0)){
      setTimeout(()=>{ generatePieces(); checkGameOver(); }, 300);
    } else setTimeout(()=> checkGameOver(), 120);
  } else setTimeout(()=> checkGameOver(), 120);
});

/* -------------------- PREVIEW / GLOW -------------------- */
function clearAllPreview(){
  document.querySelectorAll('.cell.preview').forEach(el=>el.classList.remove('preview','glow'));
}
function updatePreviewGlow(e){
  if (!dragInfo) return;
  const rect = BOARD.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const cellW = rect.width / COLS;
  const cellH = rect.height / ROWS;
  const c = Math.floor(x / cellW);
  const r = Math.floor(y / cellH);
  clearAllPreview();
  const s = dragInfo.shape;
  if (!s) return;
  // validate
  let valid = true;
  for(let i=0;i<s.length;i++){
    for(let j=0;j<s[0].length;j++){
      if (s[i][j]===1){
        const rr=r+i, cc=c+j;
        if (rr<0||rr>=ROWS||cc<0||cc>=COLS||grid[rr][cc]===1){ valid=false; break; }
      }
    }
    if(!valid) break;
  }
  if (!valid) return;
  for(let i=0;i<s.length;i++){
    for(let j=0;j<s[0].length;j++){
      if (s[i][j]===1){
        const rr=r+i, cc=c+j;
        const index = rr*COLS + cc;
        const el = BOARD.children[index];
        if (el) el.classList.add('preview','glow');
      }
    }
  }
}

/* -------------------- PLACEMENT / SCORING / CLEARING -------------------- */
function tryPlaceAt(shape, r, c, pieceIndex){
  // validate
  for(let i=0;i<shape.length;i++){
    for(let j=0;j<shape[0].length;j++){
      if (shape[i][j]===1){
        const rr=r+i, cc=c+j;
        if (rr<0||rr>=ROWS||cc<0||cc>=COLS) return false;
        if (grid[rr][cc]===1) return false;
      }
    }
  }

  // place + fall animation: we'll mark grid occupied and animate a drop effect
  const placedEls = [];
  for(let i=0;i<shape.length;i++){
    for(let j=0;j<shape[0].length;j++){
      if (shape[i][j]===1){
        const rr=r+i, cc=c+j;
        grid[rr][cc] = 1;
        const el = BOARD.children[rr*COLS + cc];
        if (el){
          // simulate fall: start with translateY(-120px) and animate to 0
          el.style.transition = 'none';
          el.style.transform = 'translateY(-120px) scale(.92)';
          // force reflow
          void el.offsetWidth;
          el.classList.add('filled','pop');
          el.style.transition = 'transform 420ms cubic-bezier(.18,.9,.3,1), box-shadow 260ms';
          el.style.transform = 'translateY(0) scale(1)';
          placedEls.push(el);
          // cleanup pop class later
          setTimeout(()=> el.classList.remove('pop'), 420);
        }
      }
    }
  }

  // scoring: placed cells * POINT_CELL
  const placedCount = shape.flat().reduce((a,b)=>a+b,0);
  score += placedCount * POINT_CELL;

  // mark piece used & remove shape so it cannot be reused
  pieces[pieceIndex].used = true;
  pieces[pieceIndex].shape = [];
  renderPieces();
  renderGrid();

  // detect lines now
  const {rows, cols, total} = detectLines();
  if (total > 0){
    // compute base line points and multiplier
    let baseLinePoints = total * POINT_LINE;
    // multiplier: x2 if 2 lines cleared, x3 if 3, etc.
    let multiplier = Math.max(1, total);
    // perfect bonus if both row(s) and col(s) cleared simultaneously
    const perfect = (rows.length > 0 && cols.length > 0);
    // animate clears
    animateClear(rows, cols, ()=> {
      // awarding points after clear animation
      let add = baseLinePoints * multiplier;
      if (perfect) add += PERFECT_BONUS;
      score += add;
      // full clear?
      if (isBoardEmpty()){
        score += FULL_CLEAR_BONUS;
        showTransientText('+FULL ' + FULL_CLEAR_BONUS, '#ffd36b');
      }
      // combo show
      combo = (total >= 2) ? multiplier : 1;
      COMBO_EL.innerText = 'x' + combo;
      updateScoreDisplay();
      // change palette on clear
      changePaletteRandom();
    });
  } else {
    // no lines cleared -> reset combo
    combo = 1;
    COMBO_EL.innerText = 'x1';
    updateScoreDisplay();
  }

  return true;
}

/* detect rows and cols fully filled */
function detectLines(){
  const rows = [], cols = [], coords = new Set();
  for(let r=0;r<ROWS;r++){
    if (grid[r].every(v=>v===1)){
      rows.push(r);
      for(let c=0;c<COLS;c++) coords.add(`${r},${c}`);
    }
  }
  for(let c=0;c<COLS;c++){
    let ok = true;
    for(let r=0;r<ROWS;r++) if (grid[r][c]===0) { ok=false; break; }
    if (ok){
      cols.push(c);
      for(let r=0;r<ROWS;r++) coords.add(`${r},${c}`);
    }
  }
  return { rows, cols, total: coords.size };
}

/* animate clear: show explosion on cells then clear from grid */
function animateClear(rows, cols, cb){
  const coords = new Set();
  rows.forEach(r=>{ for(let c=0;c<COLS;c++) coords.add(`${r},${c}`); });
  cols.forEach(c=>{ for(let r=0;r<ROWS;r++) coords.add(`${r},${c}`); });

  // explode visuals & spawn particles
  coords.forEach(s=>{
    const [r,c] = s.split(',').map(Number);
    const el = BOARD.children[r*COLS + c];
    if (el){
      el.classList.add('explode');
      // spawn small particle burst at cell center
      spawnParticlesAtCell(r,c, 18, currentPalette.block);
    }
  });

  // after animation clear actual cells
  setTimeout(()=>{
    coords.forEach(s=>{
      const [r,c] = s.split(',').map(Number);
      const el = BOARD.children[r*COLS + c];
      if (el){ el.classList.remove('explode','filled','glow','pop'); }
      grid[r][c] = 0;
    });
    renderGrid();
    if (typeof cb === 'function') cb();
  }, 360);
}

/* check full board empty */
function isBoardEmpty(){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if (grid[r][c]===1) return false;
  return true;
}

/* -------------------- PARTICLES -------------------- */
function spawnParticlesAtCell(r,c, count=12, color='#ffd36b'){
  const cell = BOARD.children[r*COLS + c];
  if (!cell) return;
  // compute center coordinates relative to BOARD
  const rect = BOARD.getBoundingClientRect();
  const cellRect = cell.getBoundingClientRect();
  const cx = cellRect.left + cellRect.width/2 - rect.left;
  const cy = cellRect.top + cellRect.height/2 - rect.top;

  for(let i=0;i<count;i++){
    const p = document.createElement('div');
    p.style.position = 'absolute';
    p.style.left = (cx) + 'px';
    p.style.top = (cy) + 'px';
    p.style.width = '8px';
    p.style.height = '8px';
    p.style.borderRadius = '50%';
    p.style.background = color;
    p.style.opacity = '0.95';
    p.style.zIndex = 70;
    p.style.pointerEvents = 'none';
    p.style.transform = 'translate(-50%,-50%) scale(1)';
    p.style.filter = 'blur(0.6px)';
    PARTICLE_LAYER.appendChild(p);

    // random velocity
    const angle = Math.random()*Math.PI*2;
    const speed = 20 + Math.random()*50;
    const dx = Math.cos(angle)*speed;
    const dy = Math.sin(angle)*speed - (Math.random()*40); // bias up
    const rot = (Math.random()*360);

    p.animate([
      { transform: `translate(${0}px,${0}px) scale(1)`, opacity:1 },
      { transform: `translate(${dx}px,${dy}px) scale(.6) rotate(${rot}deg)`, opacity:0 }
    ], { duration: 550 + Math.random()*350, easing: 'cubic-bezier(.2,.8,.2,1)' });

    setTimeout(()=> p.remove(), 900 + Math.random()*400);
  }
}

/* -------------------- CHECK GAME OVER -------------------- */
/* Determine if any remaining piece can be placed anywhere */
function canPlaceAnywhere(shape){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let ok=true;
      for(let i=0;i<shape.length;i++){
        for(let j=0;j<shape[0].length;j++){
          if (shape[i][j]===1){
            const rr=r+i, cc=c+j;
            if (rr<0||rr>=ROWS||cc<0||cc>=COLS) { ok=false; break; }
            if (grid[rr][cc]===1) { ok=false; break; }
          }
        }
        if (!ok) break;
      }
      if (ok) return true;
    }
  }
  return false;
}

/* After every move or piece generation, call checkGameOver */
function checkGameOver(){
  for(let i=0;i<pieces.length;i++){
    const p = pieces[i];
    if (!p || p.used || !p.shape || p.shape.length===0) continue;
    if (canPlaceAnywhere(p.shape)) return false;
  }
  // none placeable -> game over
  showGameOver();
  return true;
}

/* -------------------- GAME OVER UI -------------------- */
function showGameOver(){
  document.getElementById('goTitle').innerText = 'Game Over';
  document.getElementById('goMsg').innerText = 'Không còn ô nào để đặt. Chơi lại?';
  OVERLAY.classList.add('show');
  OVERLAY.setAttribute('aria-hidden','false');
}

function hideGameOver(){
  OVERLAY.classList.remove('show');
  OVERLAY.setAttribute('aria-hidden','true');
}

/* -------------------- SCORE & UI -------------------- */
function updateScoreDisplay(){
  SCORE_EL.innerText = score;
  if (score > best){
    best = score; BEST_EL.innerText = best; localStorage.setItem('bb_best_pro_v2', best);
  }
}

/* transient big text for bonuses */
function showTransientText(text, color='#ffd36b'){
  const t = document.createElement('div');
  t.textContent = text;
  t.style.position='fixed'; t.style.left='50%'; t.style.top='18%'; t.style.transform='translateX(-50%)'; t.style.zIndex=200;
  t.style.padding='8px 14px'; t.style.borderRadius='12px'; t.style.fontWeight='900'; t.style.color='#071018';
  t.style.background = color; t.style.opacity='0'; t.style.transition='all 260ms cubic-bezier(.2,.9,.2,1)';
  document.body.appendChild(t);
  requestAnimationFrame(()=>{ t.style.opacity=1; t.style.transform='translateX(-50%) translateY(-6px)'; });
  setTimeout(()=>{ t.style.opacity=0; t.style.transform='translateX(-50%) translateY(-26px)'; }, 900);
  setTimeout(()=> t.remove(), 1200);
}

/* -------------------- PALETTE UTILS -------------------- */
function changePaletteRandom(){
  const p = pick(PALETTES);
  applyPalette(p);
  BOARD.classList.add('flash');
  setTimeout(()=> BOARD.classList.remove('flash'), 320);
}

/* -------------------- RENDER / INIT FUNCTIONS -------------------- */
function renderPieces(){ /* re-rendered when pieces changes */ }
function renderBoardAndPieces(){
  renderGrid();
  renderPieces();
  updateScoreDisplay();
}

/* initial build */
function boot(){
  initGrid();
  buildBoardDOM();
  applyPalette(pick(PALETTES));
  generatePieces();
  renderGrid();
  BEST_EL.innerText = best;
  updateScoreDisplay();
}

/* -------------------- small helpers / finalize -------------------- */
function renderGrid(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      const el = BOARD.children[idx];
      if (!el) continue;
      if (grid[r][c] === 1){
        el.classList.add('filled');
      } else {
        el.classList.remove('filled','explode','glow','preview','pop');
      }
    }
  }
}

/* override renderPieces with full implementation */
function renderPieces(){
  SLOTS.innerHTML = '';
  pieces.forEach((p, idx)=>{
    const slot = document.createElement('div');
    slot.className = 'slot';
    slot.dataset.idx = idx;
    if (!p || p.used || !p.shape || p.shape.length===0){
      slot.classList.add('empty');
      slot.innerHTML = '<div style="color:var(--muted);font-size:13px">Used</div>';
      SLOTS.appendChild(slot);
      return;
    }

    const preview = document.createElement('div');
    preview.className = 'previewGrid';
    const cols = p.shape[0].length || 1;
    preview.style.gridTemplateColumns = `repeat(${cols}, auto)`;

    p.shape.forEach(row=>{
      const rEl = document.createElement('div');
      rEl.className = 'previewRow';
      row.forEach(cell=>{
        const mini = document.createElement('div');
        mini.className = 'previewCell';
        if (cell===1) mini.style.background = currentPalette.block;
        else mini.style.background = 'rgba(255,255,255,0.03)';
        rEl.appendChild(mini);
      });
      preview.appendChild(rEl);
    });

    slot.appendChild(preview);
    slot.addEventListener('pointerdown', (ev)=>{
      ev.preventDefault();
      if (p.used) return;
      startDrag(ev, idx);
    });

    SLOTS.appendChild(slot);
  });
}

/* -------------------- RESET / RESTART -------------------- */
function resetGame(){
  grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
  score = 0; combo = 1;
  pieces = [];
  applyPalette(pick(PALETTES));
  renderBoardAndPieces();
  generatePieces();
  hideGameOver();
  updateScoreDisplay();
}

/* -------------------- PLUG UI BUTTONS -------------------- */
document.getElementById('btnPalette').addEventListener('click', ()=> changePaletteRandom());
document.getElementById('btnTheme').addEventListener('click', ()=>{
  document.documentElement.classList.toggle('light');
});
document.getElementById('btnNew').addEventListener('click', ()=> {
  generatePieces();
  checkGameOver();
});
document.getElementById('btnReset').addEventListener('click', ()=> resetGame());
document.getElementById('btnRestart').addEventListener('click', ()=> { hideGameOver(); resetGame(); });
document.getElementById('btnClose').addEventListener('click', ()=> { hideGameOver(); });

/* -------------------- START -------------------- */
boot();

</script>
</body>
</html>
